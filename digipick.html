<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digipicker</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background-color: rgb(175, 175, 175);
        font-family: 'Gill Sans', sans-serif;
    }

    canvas {
        position: absolute;
        pointer-events: none;
    }


    #screenshotCanvas {
        display: none;
    }

    #placementGrid .step1, 
    #placementGrid .step2, 
    #placementGrid .step3,
    #placementGrid .radioOptions1,
    #placementGrid .radioOptions2,
    #loadImageButton {
        flex-basis: 50%; /* Each element will take up 50% of the container's width */
        display: flex;
        align-items: center;
        justify-content: flex-start; 
        padding-left: 15px;
    }

    #loadImageButton button {
        background-color: rgba(37, 37, 37, 0.5);
        color: white;
        border: 1px solid rgb(237, 237, 237);
        border-radius: 5px;
        padding: 10px 15px;
        cursor: pointer;
        outline: none;
        transition: background-color 0.2s;
    }

    #loadImageButton button:hover {
        background-color: rgba(37, 37, 37, 0.7);
    }
    
       
    .radioOptions1 input[type="radio"],
    .radioOptions2 input[type="radio"] {
        display: none;
    }
    
    .radioOptions1 label,
    .radioOptions2 label {
        background-color: rgba(37, 37, 37, 0.5);
        color: white;
        border: 2px solid rgb(237, 237, 237);
        border-radius: 5px;
        padding: 10px 15px;
        cursor: pointer;
        margin-right: 10px;
        display: inline-block;
        transition: background-color 0.2s;
        font-size: 18px;
    }

    .radioOptions1 label:hover,
    .radioOptions2 label:hover {
        background-color: rgba(37, 37, 37, 0.7);
    }
    
    .radioOptions1 input[type="radio"]:checked + label,
    .radioOptions2 input[type="radio"]:checked + label {
        background-color: rgba(37, 37, 37);
    }

    .radioOptions1 input[type="radio"]:checked + label,
    .radioOptions2 input[type="radio"]:checked + label {
        background-color: rgba(37, 37, 37);
        position: relative; /* Needed to position the pseudo-element correctly */
    }
    
    .radioOptions1 input[type="radio"]:checked + label::before,
    .radioOptions2 input[type="radio"]:checked + label::before {
        content: "";  /* This is required for the pseudo-element to appear */
        position: absolute;
        left: 0; 
        top: 0; 
        bottom: 0;
        width: 10%; /* Set the width to 10% of the button's width */
        background-color: white; 
        border-top-left-radius: 2px;  /* Match the rounded corners of the label */
        border-bottom-left-radius: 2px;
    }
    
    button {
        font-size: 18px;
    }

        
    #placementGrid {
        font-size: 18px;
        position: absolute;
        top: 10%;
        left: 5%; /* Adjust this to set the left positioning to 15% of the window width */
        width: 80%;
        height: 80%;
        z-index: 1;
        display: flex;
        flex-wrap: wrap;
        row-gap: 50px;
        justify-content: left; /* Left align children horizontally */
    }

    .radioOptions1 label,
    .radioOptions2 label {
        margin-left: 0;
    }
    
    #loadImageButton button {
        margin: 0;
    }

    #resultCanvas {
        position: fixed;      /* Makes sure the canvas stays at a fixed position */
        right: 0;             /* Align to the right edge of the viewport */
        top: 50%;             /* Move the top edge of the canvas to the vertical center of the viewport */
        transform: translateY(-50%);  /* Pull the canvas up by half its own height */
        /*bottom: 0;            /* Align to the bottom edge of the viewport */
    }

</style>
</head>

<body>
    <canvas id="backgroundCanvas"></canvas>
    <canvas id="screenshotCanvas"></canvas>

    <div id="placementGrid">
        <div class="step1">SELECT LOCK LEVEL</div>
        <div class="radioOptions1">
            <input type="radio" id="novice" name="difficulty" value="NOVICE">
            <label for="novice">NOVICE</label>
            
            <input type="radio" id="advanced" name="difficulty" value="ADVANCED">
            <label for="advanced">ADVANCED</label>
            
            <input type="radio" id="expert" name="difficulty" value="EXPERT">
            <label for="expert">EXPERT</label>
            
            <input type="radio" id="master" name="difficulty" value="MASTER">
            <label for="master">MASTER</label>
        </div>
        <div class="step2">SELECT RESOLUTION</div>
        <div class="radioOptions2">
            <input type="radio" id="1920x1080" name="1920x1080" value="1920x1080">
            <label for="1920x1080">1920x1080</label>
            
        </div>
        <div class="step3">SELECT SCREENSHOT</div>
        <div id="loadImageButton">
            <button>LOAD</button>
            <input type="file" id="loadImageInput" style="display: none;">
        </div>
        <canvas id="resultCanvas"></canvas>
    </div>
    <script>
class Utilities {

    /**
     * Updates or inserts URL parameters based on provided key-value pairs.
     * If the page is hosted on domains like htmlpreview.github.io where manipulating the actual URL is problematic,
     * it falls back to using localStorage for preserving the parameters.
     * 
     * @param {Array} keyValuePairs - An array of key-value pairs to upsert.
     */
    updateURLParameters(keyValuePairs) {
        // Attempt to fetch any existing parameters from localStorage. If none exist, 
        // fall back to fetching from the current URL's search parameters.
        const storedParams = localStorage.getItem('urlParameters');
        const params = storedParams 
                       ? new URLSearchParams(storedParams) 
                       : new URLSearchParams(window.location.search);
        
        // Iterate over the provided key-value pairs
        // If a key already exists, its value gets updated (hence, "upsert" - update/insert).
        keyValuePairs.forEach(pair => {
            params.set(pair.key, pair.value);
        });
        
        // Once we've added all the new key-value pairs, 
        // save the entire set of parameters back to localStorage.
        localStorage.setItem('urlParameters', params.toString());
        
        // Try updating the current browser URL without causing a page reload.
        // This helps in preserving state in the URL for user's convenience, sharing, etc.
        try {
            window.history.replaceState({}, '', '?' + params.toString());
        } catch (error) {
            // If updating the browser URL fails (e.g., due to security restrictions, 
            // iframe sandboxing, etc.), log a warning.
            // The parameters are still safely stored in localStorage at this point.
            console.warn("Failed to update window.history. Using localStorage as fallback.");
        }
    }
    
    /**
     * Retrieves the URL parameters.
     * 
     * This function first tries to fetch the parameters directly from the URL.
     * If the page is hosted on 'htmlpreview.github.io', it attempts to retrieve the parameters 
     * from the localStorage instead, as URL parameters might not be accurately represented 
     * in the browser's address bar due to how htmlpreview.github.io functions.
     * 
     * @returns {URLSearchParams} - An instance of URLSearchParams populated with the current parameters.
     */
    getURLParameters() {
        // Initialize by trying to fetch parameters directly from the URL
        let urlParams = new URLSearchParams(window.location.search);
    
        // Check if the page is hosted on htmlpreview.github.io
        if (window.location.hostname.includes('htmlpreview.github.io')) {
            // Try to get the stored parameters from localStorage
            const storedParams = localStorage.getItem('urlParameters');
            if (storedParams) {
                urlParams = new URLSearchParams(storedParams);
            }
        }
    
        return urlParams;
    }
    
    /**
    * Draws the colored bars on the left
    */
    drawLeftGraphics() {
                

    
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        screenshotCanvas.width = window.innerWidth;
        screenshotCanvas.height = window.innerHeight;
        resultCanvas.width = window.innerWidth / 2;
        resultCanvas.height = window.innerHeight / 2;
    
        const gradientWidth = 0.009 * window.innerWidth;
    
        const gradients = [
            { color: 'rgba(41, 78, 123', name: 'gradientLeftBlue' },
            { color: 'rgba(222, 163, 61', name: 'gradientLeftYellow' },
            { color: 'rgba(234, 90, 40', name: 'gradientLeftOrange' },
            { color: 'rgba(216, 0, 51', name: 'gradientLeftRed' }
        ];
    
        for (let i = 0; i < gradients.length; i++) {
            const gradient = bgCtx.createLinearGradient(gradientWidth * i, 0, gradientWidth * (i + 1), bgCanvas.height);
            gradient.addColorStop(0, `${gradients[i].color}, 1)`);
            gradient.addColorStop(0.8, `${gradients[i].color}, 0.2)`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
    
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(gradientWidth * i, 0, gradientWidth, bgCanvas.height);
        }
    }

    /**
     * Draws the gray graphics on the right
     */
    drawRightGraphics() {
        // Define the bar's width and initial start point
        const barWidth = 0.027 * window.innerWidth;
        const initialStartX = 0.7 * window.innerWidth;
        const startY = 0.2 * window.innerHeight;
        
        // Define the offset between bars
        const offsetX = 0.005 * window.innerWidth;
    
        // Initial bend starting point
        let bendStartY = 0.75 * window.innerHeight;
    
        // Calculate control points for the bezier curve
        const controlPoint2XOffset = barWidth;
        const controlPoint2YOffset = barWidth;
    
        // Calculate the end points after the curve, going 25% off the viewport to ensure it's off screen
        const distanceAfterCurve = (window.innerHeight + bendStartY) + (0.25 * window.innerHeight);
        
        for (let i = 2; i < 8; i++) {
            const startX = initialStartX + (i * (barWidth + offsetX));
            
            if (i === 2) {
                // Draw the text "STARWARE" above the lines, 40 font size, bold
                bgCtx.fillStyle = 'rgb(133, 133, 133)';
                bgCtx.font = "bold 40px Arial";
                bgCtx.textAlign = "left";
                bgCtx.fillText("STARWARE", startX, startY - 60);
                
                // Draw the text "DIGIPICKER SYSTEM" below the STARWARE, 20 font size
                bgCtx.font = "20px Arial";
                bgCtx.fillText("DIGIPICKER SYSTEM", startX, startY - 20);
            }

            const controlPoint1X = startX;
            const controlPoint1Y = bendStartY + (i * (barWidth + offsetX));
            const controlPoint2X = startX - controlPoint2XOffset;
            const controlPoint2Y = bendStartY + controlPoint2YOffset;
            const endX = startX - distanceAfterCurve * Math.cos(Math.PI / 4) + (i * (barWidth + offsetX)); 
            const endY = bendStartY + distanceAfterCurve * Math.sin(Math.PI / 4); 
            
            bgCtx.strokeStyle = 'rgb(133, 133, 133)';
            bgCtx.lineWidth = barWidth;
            bgCtx.beginPath();
            bgCtx.moveTo(startX, startY);
            bgCtx.lineTo(startX, bendStartY);
            bgCtx.bezierCurveTo(controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y, endX, endY);
            bgCtx.stroke();
    
            // Adjust the bend's starting point based on the offset
            bendStartY -= offsetX;
        }
    }

    
}
        
// CONSTANTS
// -------------------------------------------------------        
const utilities = new Utilities();
const params = utilities.getURLParameters();

const bgCanvas = document.getElementById('backgroundCanvas');
const screenshotCanvas = document.getElementById('screenshotCanvas');
const resultCanvas = document.getElementById('resultCanvas');

const bgCtx = bgCanvas.getContext('2d', { willReadFrequently: true });
const screenshotCtx = screenshotCanvas.getContext('2d', { willReadFrequently: true });
const resultCtx = resultCanvas.getContext('2d', { willReadFrequently: true });
        
// Lock Level button events
// -------------------------------------------------------
const levelParameters = {
    'novice': [
        { key: 'r_c', value: 2 }, // lock rings count
        { key: 'dp_c', value: 4 },// digipick count
        { key: 'dp_d', value: 0 } // digipick difficulty used to get the y offset for the digipick rings
    ],
    'advanced': [
        { key: 'r_c', value: 2 }, // lock rings count
        { key: 'dp_c', value: 6 },// digipick count
        { key: 'dp_d', value: 1 } // digipick difficulty used to get the y offset for the digipick rings
    ],
    'expert': [
        { key: 'r_c', value: 3 }, // lock rings count
        { key: 'dp_c', value: 9 }, // digipick count
        { key: 'dp_d', value: 2 }  // digipick difficulty used to get the y offset for the digipick rings
    ],
    'master': [
        { key: 'r_c', value: 4 }, // lock rings count
        { key: 'dp_c', value: 12 }, // digipick count
        { key: 'dp_d', value: 3 } // digipick difficulty used to get the y offset for the digipick rings
    ]
};

for (let level in levelParameters) {
    document.getElementById(level).addEventListener('click', function() {
        utilities.updateURLParameters(levelParameters[level]);
    });
}

// Resolution button events
// -------------------------------------------------------
const resolutionParameters = {
    '1920x1080': [
        { key: 'r_x', value: 960 }, // lock rings center x location
        { key: 'r_y', value: 540 }, // lock rings center y location
        { key: 'r_r0', value: 204 }, // outer most ring radius
        { key: 'r_r1', value: 167 },
        { key: 'r_r2', value: 134 },
        { key: 'r_r3', value: 99 }, // inner most ring radius

        { key: 'dp_radius', value: 39 }, // digipick ring radius
        { key: 'dp_x', value: 1405 }, // top left digipick ring center x location
        { key: 'dp_y0', value: 560 }, // y0 = y offset for novice difficulty
        { key: 'dp_y1', value: 510 }, // y1 = y offset for advanced difficulty
        { key: 'dp_y2', value: 460 }, // y2 = y offset for expert difficulty
        { key: 'dp_y3', value: 410 }, // y3 = y offset for master difficulty
        { key: 'dp_hd', value: 113 }, // horizontal distance between digipick circle centers
        { key: 'dp_vd', value: 111 }  // vertical distance between digipick circle centers
    ],
};

for (let resolution in resolutionParameters) {
    document.getElementById(resolution).addEventListener('click', function() {
        utilities.updateURLParameters(resolutionParameters[resolution]);
    });
}


        
// Load button event
// -------------------------------------------------------
document.querySelector('#loadImageButton button').addEventListener('click', function() {
    const button = document.getElementById('loadImageButton').querySelector('button');

    button.textContent = 'LOADING...';
    
    setTimeout(() => {
        //clearInterval(interval);
        button.textContent = 'LOAD';
    }, 10000);  // For demonstration, stopping after 10 seconds
 
    document.getElementById('loadImageInput').click();
});

document.getElementById('loadImageInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                screenshotCanvas.width = img.width;
                screenshotCanvas.height = img.height;
                screenshotCtx.clearRect(0, 0, screenshotCanvas.width, screenshotCanvas.height);
                
                screenshotCtx.drawImage(img, 0, 0, screenshotCanvas.width, screenshotCanvas.height);
                resultCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
                
                solveLock();  // Calling the solveLock function

                // Define the size and position for the cropped part
                const trimTop = 0.2 * screenshotCanvas.height;
                const trimBottom = 0.2 * screenshotCanvas.height;
                const trimLeft = 0.3 * screenshotCanvas.width; // Calculate the left trim
                
                const drawHeight = screenshotCanvas.height - trimTop - trimBottom;
                const drawWidth = screenshotCanvas.width - trimLeft; // Adjust the width for the cropped section
                
                // Calculate the aspect ratio of the cropped image section
                const aspectRatio = drawWidth / drawHeight;
                
                // Adjust the size of resultCanvas to be 70% of the cropped section and maintain the aspect ratio
                resultCanvas.width = 0.7 * drawWidth;
                resultCanvas.height = resultCanvas.width / aspectRatio;
                
                // Adjust drawImage method to trim from the left side as well
                resultCtx.drawImage(screenshotCanvas, trimLeft, trimTop, drawWidth, drawHeight, 0, 0, resultCanvas.width, resultCanvas.height);

            }

            img.src = event.target.result;
        }
        reader.readAsDataURL(file);
    }
});


// Graphics
// -------------------------------------------------------   
utilities.drawLeftGraphics();
utilities.drawRightGraphics();

// AI Solver
// -------------------------------------------------------
        
function loadImage() {
    const file = document.getElementById('fileInput').files[0];
    if (file) {
        const reader = new FileReader();

        reader.onload = function (event) {
            const img = new Image();
            img.onload = function () {
                // Create an off-screen canvas and draw the entire image onto it
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = img.width;
                offscreenCanvas.height = img.height;
                const offscreenCtx = offscreenCanvas.getContext('2d');
                offscreenCtx.drawImage(img, 0, 0);

                // Define the subrectangle's top-left coordinates and its dimensions
                const startX = 0;
                const startY = 0;
                const width = img.width;
                const height = img.height;

                // Set the main canvas width and height to the subrectangle's dimensions
                canvas.width = width;
                canvas.height = height;

                // Clear the main canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the desired subrectangle onto the main canvas
                ctx.drawImage(offscreenCanvas, startX, startY, width, height, 0, 0, width, height);

                // Call the solvePuzzle function after the image is loaded
                solvePuzzle();
            };
            img.src = event.target.result;
        };

        reader.readAsDataURL(file);
    }
}

function drawPixelWithText(x, y, text) {
    // Drawing a pixel at the specified coordinates
    if (text.endsWith('_1')) {
        screenshotCtx.fillStyle = 'white';
    }

    if (text.endsWith('_0')) {
        screenshotCtx.fillStyle = 'red';
    }

    screenshotCtx.fillRect(x, y, 2, 2);

    // Drawing the provided text 5 pixels above the pixel
    screenshotCtx.font = '6px sans-serif';
    screenshotCtx.fillStyle = 'white';

    if (!text.startsWith('!')) {
        screenshotCtx.fillText(text, x + 4, y - 4);
    }

    // Logging the colorText to the console
    //console.log(text);
}

function getPixelColor(x, y, context, lean) {
    let colors = [];

    const offsets = [
        [-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2], // Top two rows
        [-2, -1], [-1, -1], [0, -1], [1, -1], [2, -1],
        [-2, 0], [-1, 0], [1, 0], [2, 0], // Middle row excluding center pixel
        [-2, 1], [-1, 1], [0, 1], [1, 1], [2, 1], // Bottom two rows
        [-2, 2], [-1, 2], [0, 2], [1, 2], [2, 2]
    ];

    offsets.forEach(offset => {
        const sampleX = x + offset[0];
        const sampleY = y + offset[1];

        const pixelData = context.getImageData(sampleX, sampleY, 1, 1).data;

        colors.push(pixelData);
    });

    // Sort by brightness
    colors.sort((a, b) => {
        const brightnessA = (a[0] + a[1] + a[2]) / 3;
        const brightnessB = (b[0] + b[1] + b[2]) / 3;
        return brightnessB - brightnessA; // Descending order
    });

    // Depending on lean value, select either the three darkest or three lightest colors
    const selectedColors = lean === 0 ? colors.slice(-3) : colors.slice(0, 3);  // -3 gives the last 3 elements

    let totalR = 0;
    let totalG = 0;
    let totalB = 0;

    selectedColors.forEach(color => {
        totalR += color[0];
        totalG += color[1];
        totalB += color[2];
    });

    // Calculate the average color from the 3 selected pixels
    const averageR = Math.round(totalR / 3);
    const averageG = Math.round(totalG / 3);
    const averageB = Math.round(totalB / 3);

    return [averageR, averageG, averageB];
}


function arrayToBinaryInt(arr) {
    return parseInt(arr.join(''), 2);
}

function intToPaddedBinary(num) {
    return (num >>> 0).toString(2).padStart(32, '0');
}

function getRingAverageColor(centerX, centerY, radius, context, N) {
    let sampledColors = [];

    // Sample 32 colors from around the circle
    for (let i = 0; i < 32; i++) {
        let angle = (i * 11.25) * (Math.PI / 180);
        let x = parseInt(centerX) + (radius * Math.cos(angle));
        let y = parseInt(centerY) + (radius * Math.sin(angle));

        let color = getPixelColor(x, y, screenshotCtx, 1);
        sampledColors.push(color);
    }

    // Sort the sampled colors based on brightness (using the formula for relative luminance)
    sampledColors.sort((a, b) => {
        const brightnessA = 0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2];
        const brightnessB = 0.2126 * b[0] + 0.7152 * b[1] + 0.0722 * b[2];
        return brightnessB - brightnessA; // Sort in descending order
    });

    let totalR = 0;
    let totalG = 0;
    let totalB = 0;
    let count = Math.abs(N);

    if (N > 0) { // If N is positive, take the top N brightest colors
        for (let i = 0; i < count && i < 32; i++) {
            totalR += sampledColors[i][0];
            totalG += sampledColors[i][1];
            totalB += sampledColors[i][2];
        }
    } else { // If N is negative, take the darkest N colors
        for (let i = 32 - count; i < 32 && i >= 0; i++) {
            totalR += sampledColors[i][0];
            totalG += sampledColors[i][1];
            totalB += sampledColors[i][2];
        }
    }

    const averageColor = [Math.round(totalR / count), Math.round(totalG / count), Math.round(totalB / count)];

    return averageColor;
}
        
function getRingBits(centerX, centerY, radius, context) {
    let bits = [];
    const sampled1Color = getRingAverageColor(centerX, centerY, radius, context, 10); // TWEAK very little maybe up or down +-1  12 made the ring 2 white
    const sampled0Color = getRingAverageColor(centerX, centerY, radius, context, -1); // TWEAK very little maybe up or down +-1

    // Use the average color to determine the bit value for all the sampled colors
    for (let i = 0; i < 32; i++) {
        let angle = (i * 11.25) * (Math.PI / 180);
        let x = parseInt(centerX) + (radius * Math.cos(angle));
        let y = parseInt(centerY) + (radius * Math.sin(angle));

        let sampledColor = getPixelColor(x, y, screenshotCtx, 1); // lean = 1 to lighter pixels
        let bitValue = closestToColor(sampledColor, sampled0Color, sampled1Color);

        drawPixelWithText(x, y, "!" + i + "_" + bitValue); // prefix text with ! to make it not draw text
        bits.push(bitValue);
    }

    return arrayToBinaryInt(bits);
}
        

function getDigiBits(centerX, centerY, radius, context) {
    let bits = [];
    let totalR = 0;
    let totalG = 0;
    let totalB = 0;

    // Calculate the average color from the 32 sampled colors
    for (let i = 0; i < 32; i++) {
        let angle = (i * 11.25) * (Math.PI / 180);
        let x = parseInt(centerX) + (radius * Math.cos(angle));
        let y = parseInt(centerY) + (radius * Math.sin(angle));

        let sampledColor = getPixelColor(x, y, screenshotCtx, 0); // lean = 0 to darker pixels

        totalR += sampledColor[0];
        totalG += sampledColor[1];
        totalB += sampledColor[2];
    }

    // average color is sampled from around the ring, should end up as dark gray color for digi picks
    const averageColor = [Math.round(totalR / 32), Math.round(totalG / 32), Math.round(totalB / 32)];

    // Use the average color to determine the bit value for all the sampled colors
    for (let i = 0; i < 32; i++) {
        let angle = (i * 11.25) * (Math.PI / 180);
        let x = parseInt(centerX) + (radius * Math.cos(angle));
        let y = parseInt(centerY) + (radius * Math.sin(angle));

        let sampledColor = getPixelColor(x, y, screenshotCtx, 1); // lean = 1 to lighter pixels

        let whiteDigiColor = [183, 183, 183]; // white digi key color

        let bitValue = closestToColor(sampledColor, averageColor, whiteDigiColor);

        drawPixelWithText(x, y, "!" + i + "_" + bitValue);
        bits.push(bitValue);
    }

    return arrayToBinaryInt(bits);
}

function closestToColor(testColor, zeroColor, oneColor) {
    function euclideanDistance(color1, color2) {
        return Math.sqrt(
            Math.pow(color1[0] - color2[0], 2) +
            Math.pow(color1[1] - color2[1], 2) +
            Math.pow(color1[2] - color2[2], 2)
        );
    }

    const zeroDistance = euclideanDistance(testColor, zeroColor);
    const oneDistance = euclideanDistance(testColor, oneColor);

    return zeroDistance < oneDistance ? 0 : 1;
}

//-------------------------------------------------------------------------
// End of ring and digipick detection helpers
//-------------------------------------------------------------------------
function intToPaddedBinary(num) {
    return (num >>> 0).toString(2).padStart(32, '0');
}

function isRingSolved(ringInt) {
    return intToPaddedBinary(ringInt) === '11111111111111111111111111111111';
}

function keyFits(key, keyhole) {
    return (key & keyhole) === 0;
}

function getPossiblePickRotations(value, context) {
    // Ensure value is a 32-bit integer
    value = value >>> 0;

    let results = [];
    let originalValue = value;

    // Rotate left for 32 times
    for (let i = 0; i < 32; i++) {
        let highBit = value & 0x80000000;  // Get the highest bit
        value = (value << 1) & 0xFFFFFFFF; // Left shift and mask to keep within 32 bits

        if (highBit) {
            // If the highest bit was 1, set the lowest bit to 1
            value |= 1;
        }

        //console.log('possiblerotation ' + context + ':' + intToPaddedBinary(value));

        // Only push to results if the value does not already exist in the results
        if (!results.includes(value)) {
            results.push(value);
        }
    }

    return results;
}

function applyActionToRing(intAction, intRing) {
    // Validate the inputs
    if (typeof intAction !== 'number' || typeof intRing !== 'number') {
        throw new Error('Invalid input to applyActionToRing');
    }

    // Add the intAction value to the intRing
    return intRing + intAction;
}

function recursiveSolver(actions, ring, currentActions = []) {
    if (isRingSolved(ring)) {
        return currentActions;
    }

    if (actions.length === 0) {
        return null;  // This means no solution was found with the current path.
    }

    let shortestSolution = null;

    for (let i = 0; i < actions.length; i++) {
        let action = actions[i];

        // Apply the action
        let debugRing = intToPaddedBinary(ring);
        let debugAction = intToPaddedBinary(action.int);
        let updatedRing = applyActionToRing(action.int, ring);
        let debugUpdatedRing = intToPaddedBinary(updatedRing);

        // Remove all other actions with the same digipicknum
        let remainingActions = actions.filter(act => act.digipicknum !== action.digipicknum);

        // Recursively call the function
        let result = recursiveSolver(remainingActions, updatedRing, [...currentActions, action]);

        if (result) {
            if (!shortestSolution || result.length < shortestSolution.length) {
                shortestSolution = result;
            }
        }
    }

    return shortestSolution;
}

function drawActionBits(ctx, digiPickInfo, greedyActions) {
    for (let order = 0; order < greedyActions.length; order++) {
        const action = greedyActions[order];
        let binaryStr = action.string; // Assuming the 'string' property of the action object holds the binary representation

        // Get the corresponding digiPick's center and radius details
        let digiPick = digiPickInfo[action.digipicknum];
        // let centerX = digiPick.center[0];
        // let centerY = digiPick.center[1];
        let radius = digiPick.radius - 5;

        // Angle step for each bit
        let angleStep = (2 * Math.PI) / 32;

        for (let i = 0; i < 32; i++) {
            let angle = angleStep * i;

            // Calculate the position for the bit
            let x = digiPick.x + radius * Math.cos(angle) - 2;  // minus 2 to center the 4x4 box
            let y = digiPick.y  + radius * Math.sin(angle) - 2;  // minus 2 to center the 4x4 box

            // Set fill color based on the bit value
            ctx.fillStyle = binaryStr[i] === '1' ? 'green' : 'black';

            // Draw the 4x4 square
            ctx.fillRect(x, y, 4, 4);
        }

        // Drawing the order number in the middle of the circle
        ctx.fillStyle = 'red';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(order + 1, digiPick.x, digiPick.y); // 'order + 1' to make the numbering start from 1 instead of 0
    }
}

function hasMoreThanThreeConsecutiveZeros(str) {
    return /0000/.test(str);
}

function solveLock() {
    let rings = [];
    let ringsInfo = getRingLocations();

    let digiPicks = [];
    let digiPickInfo = getDigiPickLocations();

    let ringInt = 0;
    
    // Loop through the ringsInfo and set bits for the discovered rings
    for (let i = 0; i < ringsInfo.length; i++) {
        // An array to store the results from getRingBits for each sub-loop iteration
        let ringBitsArray = [];
    
        // Loop from ringsInfo[i].radius - 2 to ringsInfo[i].radius + 2
        for (let r = ringsInfo[i].radius - 2; r <= ringsInfo[i].radius + 2; r++) {
            ringBitsArray.push(getRingBits(ringsInfo[i].x, ringsInfo[i].y, r, 'ring' + ringsInfo[i].index));
        }
    
        // Find the numbers that appear more than once in ringBitsArray
        let freqMap = {};
        for (let j = 0; j < ringBitsArray.length; j++) {
            freqMap[ringBitsArray[j]] = (freqMap[ringBitsArray[j]] || 0) + 1;
        }
    
        let matchingNumbers = [];
        for (let num in freqMap) {
            if (freqMap[num] > 1) {
                matchingNumbers.push(num);
            }
        }
    
        // We have a sample of ring colors that may have more than one binary result
        // We take the ring binary representation that occurs more than onces
        // Assuming that's the requirement, if you want more or less, you can adjust this.
        if (matchingNumbers.length >= 2) {
            ringInt = matchingNumbers[0]; // Or do any other operation with the two matching numbers
            rings.push(ringInt);
        } else if (matchingNumbers.length == 1) {
            // We didnt have any variance and getRingBits returned a really solid result
            rings.push(ringBitsArray[0]); 
        }
 
    }

    // Loop through the digiPickInfo and set bits for the discovered digiPicks
    for (let i = 0; i < digiPickInfo.length; i++) {
        const digiPickInt = getDigiBits(digiPickInfo[i].x, digiPickInfo[i].y, digiPickInfo[i].radius, 'digipick' + digiPickInfo[i].index);
        if (!(digiPickInt === 0))
        {
            digiPicks.push(digiPickInt);    
        }
    }

    console.log("rings:");
    console.log(rings);
    console.log("picks:");
    console.log(digiPicks);

    let actions = [];

    // For each pick in digiPicks
    for (let i = 0; i < digiPicks.length; i++) {
        // console.log('Getting rotations for picknum[' + i + ']')
        let context = 'picknum[' + i + ']';
        let rotations = getPossiblePickRotations(digiPicks[i], 'picknum[' + i + ']');

        // console.log('Found ' + rotations.length + ' rotations for picknum[' + i + ']')
        // Pushing the results to the actions array
        for (let j = 0; j < rotations.length; j++) {
            for (let r = 0; r < rings.length; r++) {
                if (keyFits(rotations[j], rings[r])) {
                    // console.log('pick[' + i + ']:' + intToPaddedBinary(rotations[j]) + ' fits in ring[' + r + ']:true');

                    // Push a new action for each specific ring it fits in
                    actions.push({
                        digipicknum: i,
                        int: rotations[j],
                        string: intToPaddedBinary(rotations[j]),
                        ring: r
                    });
                } else {
                    // console.log('pick[' + i + ']:' + intToPaddedBinary(rotations[j]) + ' fits in ring[' + r + ']:false');
                }
            }
        }
    }

    // Print out the possible actions
    console.log("actions;");
    console.log(actions);

    // After we have a list of possible horizon actions, call the function to get the DFS(depth first search) actions
    let solvedActions = [];  // Array to store the final set of actions  

    // Loop through rings and solve
    for (let i = 0; i < rings.length; i++) {
        let ring = rings[i];

        // Find the actions for this ring
        let ringActions = actions.filter(action => action.ring === i);

        // Call the recursive solver for this ring
        let ringSolvedActions = recursiveSolver(ringActions, ring);

        if (ringSolvedActions) {
            solvedActions = solvedActions.concat(ringSolvedActions);

            // Update actions, removing actions from the same digipicknums as in ringSolvedActions
            let usedDigiPickNums = ringSolvedActions.map(action => action.digipicknum);
            actions = actions.filter(action => !usedDigiPickNums.includes(action.digipicknum));
        }
    }

    drawActionBits(screenshotCtx, digiPickInfo, solvedActions);

    const button = document.getElementById('loadImageButton').querySelector('button');
    button.textContent = 'LOAD';
}
        
       

function getRingLocations() {
    const params = utilities.getURLParameters();
    let r_r0 = parseInt(params.get('r_r0') || 0); // Counting outwards to inwards, the radius of the outer most ring
    let r_r1 = parseInt(params.get('r_r1') || 0); // the radius of ring 1
    let r_r2 = parseInt(params.get('r_r2') || 0); // the radius of ring 2
    let r_r3 = parseInt(params.get('r_r3') || 0); // the radius of ring 3
    let r_x = parseInt(params.get('r_x') || 0); // x coordinate for center of the rings
    let r_y = parseInt(params.get('r_y') || 0); // y coordinate for center of the rings
    let r_c = parseInt(params.get('r_c') || 0); // ring count

    let ringLocations = [
        { index: 0, x: r_x, y: r_y, radius: r_r0 },
        { index: 1, x: r_x, y: r_y, radius: r_r1 },
        { index: 2, x: r_x, y: r_y, radius: r_r2 },
        { index: 3, x: r_x, y: r_y, radius: r_r3 },
    ];

    // Draw a center dot for the rings
    drawPixelWithText(r_x, r_y, `!_0`); // ! bang makes the text not render but _0 give us red color still

    let returnRings = ringLocations.slice(0, r_c);

    console.log("ring locations:");
    console.log(returnRings);

    return returnRings;
}

function getDigiPickLocations() {
    const params = utilities.getURLParameters();
    let dp_radius = parseInt(params.get('dp_radius') || 0); // the radius of a digipick circle just 2 pixels smaller than the gray tick marks
    let dp_x = parseInt(params.get('dp_x') || 0); // x coordinate for center of topleft digipick circle
    let dp_hd = parseInt(params.get('dp_hd') || 0); // horizontal distance between digipick circle centers
    let dp_vd = parseInt(params.get('dp_vd') || 0); // vertical distance between digipick circle centers
    let dp_c = parseInt(params.get('dp_c') || 0); // digipick count
    let dp_d = parseInt(params.get('dp_d') || 0); // digipick difficulty

    // Get the y coordinate for center of topleft digipick circle from the URL
    let dp_y = parseInt(params.get(`dp_y${dp_d}`) || 0);
    
    let picks  = [
        { index: 0, x: dp_x+(0*dp_hd), y: dp_y+(0*dp_vd), radius: dp_radius },
        { index: 1, x: dp_x+(1*dp_hd), y: dp_y+(0*dp_vd), radius: dp_radius },
        { index: 2, x: dp_x+(2*dp_hd), y: dp_y+(0*dp_vd), radius: dp_radius },
        { index: 3, x: dp_x+(3*dp_hd), y: dp_y+(0*dp_vd), radius: dp_radius },
        
        { index: 4, x: dp_x+(0*dp_hd), y: dp_y+(1*dp_vd), radius: dp_radius },
        { index: 5, x: dp_x+(1*dp_hd), y: dp_y+(1*dp_vd), radius: dp_radius },
        { index: 6, x: dp_x+(2*dp_hd), y: dp_y+(1*dp_vd), radius: dp_radius },
        { index: 7, x: dp_x+(3*dp_hd), y: dp_y+(1*dp_vd), radius: dp_radius },

        { index: 8, x: dp_x+(0*dp_hd), y: dp_y+(2*dp_vd), radius: dp_radius },
        { index: 9, x: dp_x+(1*dp_hd), y: dp_y+(2*dp_vd), radius: dp_radius },
        { index: 10, x: dp_x+(2*dp_hd), y: dp_y+(2*dp_vd), radius: dp_radius },
        { index: 11, x: dp_x+(3*dp_hd), y: dp_y+(2*dp_vd), radius: dp_radius },
    ];

    let returnPicks = picks.slice(0, dp_c);
    if (dp_c < 4 || returnPicks.length === 0) {
        console.log("No digipicks found, check URL parameters");
    }
    console.log("pick locations:");
    console.log(returnPicks);
    return returnPicks;
}

    </script>
</body>
</html>
